using System.Collections.Generic;
using UnityEngine;

namespace SolarSystem
{
    [ExecuteInEditMode]
    public class CelestialBodyGenerator : MonoBehaviour
    {
        public enum PreviewMode { LOD0, LOD1, LOD2, CollisionRes }
        public ResolutionSettings resolutionSettings;
        public PreviewMode previewMode;

        public bool logTimers;

        public CelestialBodySettings body;

        bool debugDoubleUpdate = true;
        int debugNumUpdates;

        // Private variables
        Mesh previewMesh;
        Mesh collisionMesh;
        Mesh[] lodMeshes;

        ComputeBuffer vertexBuffer;

        bool shapeSettingsUpdated;
        bool shadingNoiseSettingsUpdated;
        Camera cam;

        Vector2 heightMinMax;

        // Game mode data
        int activeLODIndex = -1;
        MeshFilter terrainMeshFilter;
        Material terrainMatInstance;

        static Dictionary<int, SphereMesh> sphereGenerators;

        // Start is called once before the first execution of Update after the MonoBehaviour is created
        void Start()
        {
            if (InGameMode)
            {
                cam = Camera.main;
                HandleGameModeGeneration();
            }
        }

        // Update is called once per frame
        void Update()
        {
            if (InEditMode)
            {
                HandleEditModeGeneration();
            }
        }

        /// <summary>
        /// <para>Handles creation of celestial body when entering game mode</para>
        /// <para>This differs from the edit-mode version in the following ways:</para>
        /// <para>• creates all LOD meshes and stores them in mesh array (to be picked based on player position)</para>
        /// <para>• creates its own instances of materials so multiple bodies can exist with their own shading</para>
        /// <para>• doesn't support updating of shape/shading values once generated</para>
        /// </summary>
        void HandleGameModeGeneration()
        {
            if (CanGenerateMesh())
            {
                Dummy();

                // Generate LOD meshes
                lodMeshes = new Mesh[ResolutionSettings.numLODLevels];
                for (int i = 0; i < lodMeshes.Length; i++)
                {
                    //Vector2 lodTerrainHeightMinMax = 
                }
            }
        }

        /// <summary>
        /// <para>Handles creation of celestial body in the editor</para>
        /// <para>This allows for updating the shape/shading settings</para>
        /// </summary>
        void HandleEditModeGeneration()
        {

        }

        public void SetLOD(int lodIndex)
        {
            if (lodIndex != activeLODIndex && terrainMeshFilter != null)
            {
                activeLODIndex = lodIndex;
                terrainMeshFilter.sharedMesh = lodMeshes[lodIndex];
            }
        }

        public void OnShapeSettingChanged()
        {
            shapeSettingsUpdated = true;
        }

        public void OnShadingNoiseSettingChanged()
        {
            shadingNoiseSettingsUpdated = true;
        }

        void OnValidate()
        {
            if (body != null)
            {
                if (body.shape != null)
                {
                    body.shape.OnSettingChanged -= OnShapeSettingChanged;
                    body.shape.OnSettingChanged += OnShapeSettingChanged;
                }
                if (body.shading != null)
                {
                    body.shading.OnSettingChanged -= OnShadingNoiseSettingChanged;
                    body.shading.OnSettingChanged += OnShadingNoiseSettingChanged;
                }
            }

            resolutionSettings?.ClampResolutions();
            OnShapeSettingChanged();
        }

        void Dummy()
        {
            // Crude fix for a problem where the values in the vertex buffer were *occasionally* all zero at start of game
            // This function runs the compute shader once with single dummy input, after which it seems the problem doesn't occur
            // (Waiting until Time.frameCount > 3 before generating is another gross hack that seems to fix the problem)
            Vector3[] vertices = new Vector3[] { Vector3.zero };
            ComputeHelper.CreateStructuredBuffer(ref vertexBuffer, vertices);
            body.shape.CalculateHeights(vertexBuffer);
        }

        /// <summary>
        /// <para>Generates terrain mesh based on heights generated by the Shape object</para>
        /// <para>Shading data from the Shading object is stored in the mesh uvs</para>
        /// <para>Returns the min/max height of the terrain</para>
        /// </summary>
        Vector2 GenerateTerrainMesh(ref Mesh mesh, int resolution)
        {
            var (vertices, triangles) = CreateSphereVertsAndTris(resolution);
            ComputeHelper.CreateStructuredBuffer(ref vertexBuffer, vertices);

            float edgeLength = (vertices[triangles[0]] - vertices[triangles[1]]).magnitude;

            // Set heights
            float[] heights = body.shape.CalculateHeights(vertexBuffer);

            // Perturb vertices to give terrain a less perfectly smooth appearance
            if (body.shape.perturbVertices && body.shape.perturbCompute != null)
            {
                ComputeShader perturbShader = body.shape.perturbCompute;
                float maxPerturbStrength = body.shape.perturbStrength * edgeLength / 2f;

                perturbShader.SetBuffer(0, "points", vertexBuffer);
                perturbShader.SetInt("numPoints", vertices.Length);
                perturbShader.SetFloat("maxStrength", maxPerturbStrength);

                ComputeHelper.Run(perturbShader, vertices.Length);
                Vector3[] pertData = new Vector3[vertices.Length];
                vertexBuffer.GetData(pertData);
            }

            // Calculate terrain min/max height and set heights of vertices
            float minHeight = float.PositiveInfinity;
            float maxHeight = float.NegativeInfinity;
            for (int i = 0; i < heights.Length; i++)
            {
                float height = heights[i];
                vertices[i] *= height;
                minHeight = Mathf.Min(minHeight, height);
                maxHeight = Mathf.Max(maxHeight, height);
            }

            // Create mesh
            CreateMesh(ref mesh, vertices.Length);
            mesh.SetVertices(vertices);
            mesh.SetTriangles(triangles, 0, true);
            mesh.RecalculateNormals();

            // Shading noise data
            body.shading.Initialize(body.shape);
            Vector4[] shadingData = body.shading.GenerateShadingData(vertexBuffer);
            mesh.SetUVs(0, shadingData);

            // Create crude tangents (vectors perpendicular to surface normal)
            // This is needed (even though normal mapping is being done with triplanar)
            // because surfaceshader wants normals in tangent space
            var normals = mesh.normals;
            var crudeTangents = new Vector4[mesh.vertices.Length];
            for (int i = 0; i < vertices.Length; i++)
            {
                Vector3 normal = normals[i];
                crudeTangents[i] = new Vector4(-normal.z, 0, normal.x, 1);
            }
            mesh.SetTangents(crudeTangents);

            return new Vector2(minHeight, maxHeight);
        }

        void GenerateCollisionMesh(int resolution)
        {

        }

        void CreateMesh(ref Mesh mesh, int numVertices)
        {

        }

        /// <summary>
        /// Generate sphere (or reuse if already generated) and return a copy of the vertices and triangles
        /// </summary>
        (Vector3[] vertices, int[] triangles) CreateSphereVertsAndTris(int resolution)
        {
            if (sphereGenerators == null)
            {
                sphereGenerators = new Dictionary<int, SphereMesh>();
            }
            if (!sphereGenerators.TryGetValue(resolution, out var generator))
            {
                generator = new SphereMesh(resolution);
                sphereGenerators.Add(resolution, generator);
            }

            var vertices = new Vector3[generator.Vertices.Length];
            var triangles = new int[generator.Triangles.Length];
            System.Array.Copy(generator.Vertices, vertices, vertices.Length);
            System.Array.Copy(generator.Triangles, triangles, triangles.Length);
            return (vertices, triangles);
        }

        void ReleaseAllBuffers()
        {
            ComputeHelper.Release(vertexBuffer);
            body.shape?.ReleaseBuffers();
            //body.shading?.ReleaseBuffers();
        }

        void OnDestroy()
        {
            ReleaseAllBuffers();
        }

        bool CanGenerateMesh()
        {
            return ComputeHelper.CanRunEditModeCompute && body.shape != null && body.shape.heightMapCompute;
        }

        void LogTimer(System.Diagnostics.Stopwatch sw, string text)
        {
            if (logTimers)
            {
                Debug.Log(text + " " + sw.ElapsedMilliseconds + " ms.");
            }
        }

        /// <summary>
        /// Application.isPlaying
        /// </summary>
        bool InGameMode
        {
            get { return Application.isPlaying; }
        }

        /// <summary>
        /// !Application.isPlaying
        /// </summary>
        bool InEditMode
        {
            get { return !Application.isPlaying; }
        }

        public class TerrainData
        {
            public float[] heights;
            public Vector4[] uvs;
        }

        [System.Serializable]
        public class ResolutionSettings
        {
            public const int numLODLevels = 3;
            const int maxAllowedResolution = 500;

            public int lod0 = 300;
            public int lod1 = 100;
            public int lod2 = 50;
            public int collider = 100;

            public int GetLODResolution(int lodLevel)
            {
                switch (lodLevel)
                {
                    case 0:
                        return lod0;
                    case 1:
                        return lod1;
                    case 2:
                        return lod2;
                }
                return lod2;
            }

            public void ClampResolutions()
            {
                lod0 = Mathf.Min(maxAllowedResolution, lod0);
                lod1 = Mathf.Min(maxAllowedResolution, lod1);
                lod2 = Mathf.Min(maxAllowedResolution, lod2);
                collider = Mathf.Min(maxAllowedResolution, collider);
            }
        }
    }
}